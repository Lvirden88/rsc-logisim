# Register-Set Computer (RSC)  
**Custom CPU Architecture implemented in Logisim-evolution**

## Overview
This repository contains a complete implementation of a **Register-Set Computer (RSC)** designed and built from the ground up using **Logisim-evolution**.  
The project demonstrates low-level computer architecture concepts including datapath design, register transfer logic, control signal generation, and clocked execution.

The RSC was built to better understand how software instructions are executed at the hardware level and how control logic orchestrates data movement across a CPU.

---

## Key Features
- Custom **datapath and shared system bus**
- Multiple **general-purpose and special-purpose registers**
- Fully implemented **ALU** supporting arithmetic and logic operations
- **Program Counter (PC)**, **Instruction Register (IR)**, and memory interface
- **Clocked execution** with single-step and continuous modes
- **Control Unit** coordinating micro-operations per instruction
- Designed for clarity, correctness, and debuggability

---

## Architecture Overview

### Datapath
The datapath centers around a shared bus architecture that allows controlled data transfer between registers, the ALU, and memory components.  
Tri-state buffers and enable signals ensure that only one source drives the bus at a time.

### Register Set
The RSC includes:
- **General-purpose registers** for intermediate computation
- **Accumulator (ACC)** for ALU results
- **Program Counter (PC)** for instruction sequencing
- **Instruction Register (IR)** for opcode and operand decoding
- **Temporary / auxiliary registers** used during execution stages

Each register is clocked and supports load/enable control for precise timing.

### Arithmetic Logic Unit (ALU)
The ALU performs core arithmetic and logical operations, including:
- Addition
- Subtraction
- Bitwise AND / OR / NOT
- Shift operations 

Operation selection is controlled through dedicated ALU control signals generated by the Control Unit.

### Control Unit
The Control Unit is responsible for:
- Decoding instruction opcodes
- Generating control signals for each execution phase
- Sequencing micro-operations across clock cycles
- Coordinating register loads, ALU operations, and memory access

The design emphasizes explicit control signals rather than implicit behavior, making execution easy to trace and debug.

---

## Instruction Execution Model
Each instruction is executed over multiple clock cycles following a standard sequence:
1. **Fetch** – Instruction loaded from memory into IR
2. **Decode** – Opcode interpreted by Control Unit
3. **Execute** – ALU operations and data transfers performed
4. **Write-back** – Results stored in registers or memory

Manual clock stepping can be used to observe individual micro-operations in real time.

---

## Project Structure

RSC/
├── logisim/
│ ├── RSC.circ # Top-level CPU circuit
│ ├── PLDs.circ # Programmable Logic Device
│ └── custom_reg.circ # Register components
│
├── microcode/
│ └──RSC_Microcode_32-bit.pdf # Control signal definitions
│
├── docs/
│ ├── screenshot # Architecture and execution screenshots
│ └── program1.txt # Assembly language program to Compute F - A (in hex and display the result)
│ └── program1_bytecode.txt # byte code to run in RSC
│ └── program2.txt # Assembly language program to Perform operations, store each result in separate memory address, and display each value. (in hex)
│ └── program2_bytecode.txt # byte code to run in RSC
│ └── program3.txt # Assembly language program : Parity Checker - Check if a number has an even or odd number of 1-bits. Output: 0 if N has an even parity, 1 if N has odd parity
│ └── program3_bytecode.txt # byte code to run in RSC
├── README.md


---

## How to Run
1. Install **Logisim-evolution**
2. Open `logisim/RSC.circ`
3. Enable clock ticks or manual stepping
4. Load a program into RAM memory 
5. Observe register transfers and ALU behavior per cycle

---

## Design Goals
- **Transparency** – All control signals and data paths are explicit
- **Correctness** – Clocked logic prevents race conditions
- **Educational clarity** – Architecture designed to be readable and explainable
- **Extensibility** – Structure allows future additions (new instructions, flags, pipelining, etc.)

---

## Skills Demonstrated
- Computer Architecture
- Digital Logic Design
- Register Transfer Level (RTL) thinking
- Control signal sequencing
- Debugging clocked systems
- Hardware-software conceptual mapping

---

## Why This Project Matters
Modern software ultimately runs on hardware abstractions.  
This project demonstrates an understanding of **how CPUs actually work beneath high-level languages**, bridging the gap between software engineering and computer architecture.

---

## Author
**Lisa Virden**  
Computer Science Major  
Interests: Computer Architecture, Systems, Cybersecurity, Low-Level Programming




